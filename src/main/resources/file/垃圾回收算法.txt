一、引用计数算法
    引用一次，增加一次计数，删除引用一次，减少一次计数，只回收计数为0的对象。
    存在问题： 无法处理循环引用问题。


二、标记-清除算法
    第一阶段，从引用根节点开始，标记可到达的对象。第二阶段，遍历整个堆，清除未标记的对象。 或标记所有不可达对象，然后清除标记对象。(深入理解java虚拟机书中提到正反标记都可以)
    存在问题： stop-the-world、产生空间碎片(如果再需要分配大对象时，可能会因无法找到足够的连续内存而提前触发GC)、执行效率不稳定(如果有大量对象需要回收，则需要进行大量的标记和清除动作)


三、标记复制算法(也称复制算法)
   将内存分为两部分，每次使用其中一部分。垃圾回收时，遍历当前正使用的区域，把正在使用的对象复制到另一块内存区域并消除未使用的对象。不会产生碎片。
   存在问题： 只能使用一半的内存


四、标记-整理算法
    第一阶段从根节点开始标记可到达的对象，第二阶段遍历整个堆，将存活对象移向内存的一端。然后清除端边界外的对象。避免了碎片及空间问题


五、三色标记算法(垃圾回收线程、用户线程可并发执行)
  假如现有三个对象，A指向B，Ｂ指向Ｄ， A—>B->D
  A对象本身标记了，且A对象中所有的引用的对象也被标记了，则A为黑色
  B对象本身标记了，Ｂ对象中的引用对象还没被标记，则B为灰色
  C对象还没有遍历到，则C为白色

  场景一、如果在回收的过程中，用户线程把B指向D的引用去掉了(即B没有引用Ｄ)，则最终D不会被回收(可等到下一次回收)，D被称为浮动垃圾。产生浮动垃圾，关系不大，下次回收即可。

  场景二、如果在回收的过程中，用户线程把B指向D的引用去掉了(即B没有引用Ｄ)，但把A指向了Ｂ，因为A已经是黑色(标记完了)，此时Ｂ不会被标记到，那么会漏标且导致内存泄露。
  CMS解决方案: 如遇这种情况，则把A重新标记为灰色。但依然会漏标。此方案已过时。
  G1解决方案：STAB Snapshot At the Begining 。在Ｂ指向Ｄ引用消失的时候，把Ｂ指向Ｄ的引用保存到GC的堆栈，保证D还能被GC扫描到。垃圾回收线程工作时，遍历GC堆栈，通过引用
         找到D对象，判断D对象有没有被引用，没有则认为D对象为垃圾，可进行回收。
  ZGC解决方案： 颜色指针
