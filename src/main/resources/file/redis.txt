1.RDB持久化原理(bgsave方式)
  触发执行bgsave命令后，会进行fork()系统调用(此过程会阻塞主进程)，创建一个子进程，此时主进程和子进程共享主进程的物理内存，且内核将主进程中所有的内存页
  设置为read-only。子进程根据服务器当前状态生成rdb文件，生成rbd文件的过程中，主进程收到写命令请求，发现内存页为只读，于是触发页异常
  中断进而执行内核的一个中断例程，内核会复制一份触发异常的页(而不是全部数据)，新来的写命令会保存到复制出来页中，这就是copyonwrite写时
  复制技术。

2.AOF持久化原理
  因为所有的命令都由文件事件处理的，当有写命令请求redis时，这些写命令会先被存入aof_buf缓冲区，每当事件循环结束前，都会调用
  flushappendonlyfile函数来判断是否需要把aof_buf缓冲区中的内容写入并同步磁盘(AOF文件)。而flushappendonlyfile函数的行为由配置
  项appendfsync的值来决定
  always：  将aof_buf缓冲区中的内容写入并同步到AOF文件。
            可能会丢失一个事件循环内的数据。
  everysec：将aof_buf缓冲区中的内容写入到AOF文件(其实是暂存到了操作系统的内存缓冲区)，如果上次同步距离现在超过1秒，则再次进行同步。
            可能会丢失1s的数据。
  no：      将aof_buf缓冲区中的内容写入到AOF文件(其实是暂存到了操作系统的内存缓冲区)， 何时同步到AOF文件由操作系统决定。
            可能会丢失上次同步后所产生的写命令数据。

3.AOF重写原理
  fork()一个子进程(此过程阻塞主进程，但所需时间很短)，子进程根据服务器当前状态生成新的AOF文件。此时主进程会继续执行客户端发送的命令，
  并将命令存入到aof_buf缓冲区(会定期同步到AOF文件)
  和aof重写缓冲区。当子进程同步完成后，会向主进程发送一个信号，主进程由到信号后，会调用信号处理函数把aof重写缓冲区中的内容同步到新的
  aof文件中(信号处理函数的调用会阻塞主进程)，这之后新的AOF文件的内容与服务器当前状态一致，重命名新AOF文件并替换原AOF文件，最终完成重写。

  为什么是子进程而不是线程？
      在不使用锁的情况下保证数据的安全性。

  怎么保证新aof文件与服务器状态一致？
      主进程继续处理写命令并将命令存入到aof重写缓冲区，主进程的信号处理函数把aof重写缓冲区中的数据同步新AOF文件的过程的阻塞的。

4.Redis主从复制(2.8之前版本)
  复制分为初次复制和断线后重复制

  从服务向主服务器发送sync命令，主服务器收到sync命令后会执行bgsave命令生成RDB文件。此过程中，如果有新的命令请求过来，主服务会把命令存
  到缓冲区，RDB文件生成完成后，主服务器会把此RDB文件传送给从服务器，从服务器收到文件后会载入文件。这之后，主服务器会把缓冲区的命令发送
  给从服务器，从服务器执行命令以保持主从数据同步（这一步是阻塞？）。同步完成后进入命令传播阶段。

  命令传播阶段，主从中断重连时，从服务器又要发送sync命令重走上述流程。但sync命令非常耗资源，原因如下
      生成RDB文件因占用大量主服务的CPU、内存、磁盘资源。
      传送RDB文件会占用大量主、从服务的带宽和流量，并影响主服务响应命令的时间。
      从服务载入RDB文件会阻塞从服务器。

  因为以上缺点，所以2.8版本有了新的复制机制。

5.Redis主从复制(2.8版本)
  复制偏移量+复制积压缓冲区+服务器id

  同步过程与之前一样(同步命令为psync，有完整重同步和部分重同步两种模式，完整重同步用于初次复制)。命令传播阶段有不同，主服务器向从服务器
  传送N个字节的命令，则主服务器的复制偏移量为N，从服务器收到Ｎ个字节的命令，则从服务器的复制偏移量也为Ｎ。此时从服务器断开了与主服务器
  的连接，主服务还断续执行命令并存入到复制积压缓冲区。当从服务器重连接上主服务器后，会将自己的复制偏移量传送给主服务器，主服务器根据从服
  务器传过来的复制偏移量，判断是进行完全重同步还是部分重同步，如果复制偏移量后面的数据在复制积压缓冲区，则进行部分重同步，否则进行完全重同步。
  如果上次同步的主服务器id与当前要同步的主服务id不一致，则也会进行完全重同步。

  复制积压缓冲区：默认1M的先进先出的队列












